import os, sys, inspect
# Add ./btchip-python to path so it works as if we were importing it from the inside.
cmd_subfolder = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],"btchip-python")))
if cmd_subfolder not in sys.path:
    sys.path.insert(0, cmd_subfolder)

import bitcoinrpc
from btchip.btchip import *
from btchip.btchipUtils import *
import simplejson as json
import settings, pprint, getpass, binascii, hashlib, sys, re
from signMessage import signMessage

pp = pprint.PrettyPrinter(indent=2)
rpcConn = None

def main():

  if len(sys.argv) < 2:
    print "Usage: python signTxCoinkite.py <JSON path>"
    exit(1)

  # Get path from cli
  inputPath = sys.argv[1]

  f = open(sys.argv[1], 'r')
  signData = json.load(f)
  requestData = json.loads(signData['contents'])

  # Get Dongle
  dongle = getDongle(False) # Bool is debug mode
  app = btchip(dongle)

  # Authenticate with dongle
  pin = getpass.getpass("PIN: ")
  app.verifyPin(pin)

  result = signCoinkiteJSON(app, dongle, requestData)
  body = createReturnJSON(app, dongle, result)

  fName = 'output-' + requestData['request'] + '.json'
  fOut = open(fName, 'w')
  fOut.write(json.dumps(body))
  fOut.close()

  print "Output written to " + fName

  print json.dumps(body)

def signCoinkiteJSON(app, dongle, requestData, promptTx=True):
  result = {}
  result['cosigner'] = requestData['cosigner']
  result['request'] = requestData['request']
  result['signatures'] = []

  # Create outputs from new tx
  newTxObj = decodeRawTX(requestData['raw_unsigned_txn'])

  if promptTx:
    print "Transaction we're signing: "
    print json.dumps(newTxObj, indent=2)
    print "Please press <enter> to confirm this transaction is expected, or <ctrl-c> to exit."
    raw_input("")

  outputs = []
  for output in newTxObj['vout']:
    script = output['scriptPubKey']['hex']
    outputs.append([output['value'], bytearray(script.decode('hex'))])
    print "Adding output: %s to %s" % (output['value'], script)
  OUTPUT = get_output_script(outputs)

  wallets = {}

  # Sign each input
  for i, signInput in enumerate(requestData['inputs']):

    # Get transaction that generated this input (prev transaction)
    print "Getting previous transaction..."
    prevTXID = requestData['input_info'][i]['txn']
    UTX = bytearray(getRawTX(prevTXID).decode('hex'))
    # UTX = bytearray(requestData['raw_unsigned_txn'].decode('hex'))
    # Get the input
    print "Getting input from transaction..."
    transaction = bitcoinTransaction(UTX)
    UTXO_INDEX = requestData['input_info'][i]['out_num']
    trustedInput = app.getTrustedInput(transaction, UTXO_INDEX)
    print binascii.hexlify(trustedInput['value'])

    # Start composing transaction
    print "Creating transaction on BTChip..."
    redeemScript = requestData['redeem_scripts'][signInput[0]]['redeem']
    app.startUntrustedTransaction(True, 0, [trustedInput], bytearray(redeemScript.decode('hex')))
    app.finalizeInputFull(OUTPUT)

    # Get pub key for each input
    for path, keyHash in requestData['req_keys'].iteritems():
      print "Signing..."
      keyPath = settings.KEYPATH_BASE + "/" + path
      pubKeyRaw = app.getWalletPublicKey(keyPath)
      wallets[path] = str(compress_public_key(pubKeyRaw['publicKey'])).encode('hex')
      print "Your pubkey for %s: %s" % (keyPath, wallets[path])
      try:
        assert pubKeyRaw['address'] == keyHash[0]
      except:
        print "ERROR: Attempting to sign with pubkey " + pubKeyRaw['address'] + " but this transaction expects to " +\
          "be signed by " + keyHash[0] + ". Exiting..."
        exit(1)
      signature = app.untrustedHashSign(keyPath, "")
      result['signatures'].append([binascii.hexlify(signature), signInput[1], signInput[0]])

  return result

def createReturnJSON(app, dongle, result):
  body = {}
  body['_humans'] = "Generated by BTChip HW.1 wallet."
  body['content'] = json.dumps(result, sort_keys=True, separators=(',', ':'))

  rootKey = app.getWalletPublicKey(settings.KEYPATH_BASE)
  messageHash = sha256(body['content'])
  body['signature_sha256'] = signMessage(app, dongle, settings.KEYPATH_BASE, messageHash.encode('hex'))
  body['signed_by'] = rootKey['address'] # Bug, should use network

  return body

def sha256(x):
  return hashlib.sha256(x).digest()

def getRawTX(txID):
  return getRPCConn().getrawtransaction(txID, verbose=False)

def decodeRawTX(rawTX):
  return getRPCConn().decoderawtransaction(rawTX)

def describeRawTX(rawTX):
  return json.dumps(decodeRawTX(rawTX), indent=2)

def getRPCConn():
  global rpcConn
  if not rpcConn:
    rpcConn = bitcoinrpc.connect_to_remote(settings.RPC_USER, settings.RPC_PASSWORD, host=settings.RPC_HOST, \
      port=settings.RPC_PORT, use_https=False)
  return rpcConn

if __name__ == "__main__":
  main()
